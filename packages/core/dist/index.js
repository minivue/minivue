import{computed as ze,reactive as $e,ref as Ge,readonly as Ze,unref as Xe,proxyRefs as en,isRef as nn,toRef as tn,toValue as on,toRefs as sn,isProxy as rn,isReactive as an,isReadonly as pn,isShallow as dn,customRef as cn,triggerRef as un,shallowRef as ln,shallowReactive as mn,shallowReadonly as fn,markRaw as On,toRaw as hn,effect as yn,stop as Tn,getCurrentWatcher as En,onWatcherCleanup as xn,ReactiveEffect as gn,effectScope as vn,EffectScope as Pn,getCurrentScope as Rn,onScopeDispose as Cn}from"@vue/reactivity";import{defineComponent as te}from"vue";var S=__DEV__?Object.freeze({}):{};var I=()=>{},{isArray:D}=Array,w=Object.assign;function T(e,t){let n={};return Object.keys(e).forEach(o=>{t.includes(o)||(n[o]=e[o])}),n}function P(e){return Object.prototype.toString.call(e).slice(8,-1)}function W(e){return e===null||new Set(["undefined","boolean","number","string"]).has(typeof e)}function M(e){return e!==null&&typeof e=="object"}function k(e){return P(e)==="Object"}function d(e){return typeof e=="function"}function r(e){return`__${e}__`}function R(e,t){let n=e.indexOf(t);n>-1&&e.splice(n,1)}import{isRef as A,isProxy as ee,toRaw as ne}from"@vue/reactivity";import{watch as Z}from"@vue/reactivity";var l=[],c=-1,x=[],E=null,O=0,Y=Promise.resolve(),C=null,q=100;function U(e){e.flags&1||(l.push(e),e.flags|=1,z())}function z(){C||(C=Y.then($))}function F(e){e.flags&1||(x.push(e),e.flags|=1)}function m(){if(x.length>0){for(E=[...new Set(x)],x.length=0,O=0;O<E.length;O++){let e=E[O];e.flags&4&&(e.flags&=-2),e(),e.flags&=-2}E=null,O=0}}function $(e){__DEV__&&(e=e||new Map);let t=__DEV__?n=>G(e,n):I;try{for(c=0;c<l.length;c++){let n=l[c];__DEV__&&t(n)||(n.flags&4&&(n.flags&=-2),n(),n.flags&4||(n.flags&=-2))}}finally{for(;c<l.length;c++){let n=l[c];n.flags&=-2}c=-1,l.length=0,C=null}}function G(e,t){let n=e.get(t)||0;return n>q?(console.warn("Maximum recursive updates exceeded. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself."),!0):(e.set(t,n+1),!1)}function N(e,t,n){return __DEV__&&!d(t)&&console.warn("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."),X(e,t,n)}function X(e,t,n=S){let{immediate:o,deep:s,flush:i,once:a}=n;__DEV__&&!t&&(o!==void 0&&console.warn('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'),s!==void 0&&console.warn('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'),a!==void 0&&console.warn('watch() "once" option is only respected when using the watch(source, callback, options?) signature.'));let y=w({},n);return i==="post"?y.scheduler=u=>{F(u)}:i!=="sync"&&(y.scheduler=(u,Q)=>{Q?u():U(u)}),y.augmentJob=u=>{t&&(u.flags|=4)},Z(e,t,y)}function p(e){if(W(e)||d(e))return e;if(A(e))return p(e.value);if(ee(e))return p(ne(e));if(D(e))return e.map(t=>p(t));if(k(e)){let t={};return Object.keys(e).forEach(n=>{t[n]=p(e[n])}),t}throw new TypeError(`${P(e)} value is not supported`)}function g(e,t){M(t)&&N(A(t)?t:()=>t,()=>{this.setData({[e]:p(t)},m)},{deep:!0})}var f;function H(e,t,n){let o=e?.(t,n);if(o!==void 0){let s;return Object.keys(o).forEach(i=>{let a=o[i];if(d(a)){n&&(n[i]=a);return}s=s||{},s[i]=p(a),n&&g.call(f,i,a)}),s!==void 0&&n&&n.setData&&n.setData(s,m),s}}function j(){return f}function oe(e){if(!__MINIVUE__)return te(e);let t=e.setup,n=e.props;return e.data=H(t,{},{}),e=T(e,["setup","props"]),e.onLoad=function(o){f=this,H(t,o,f),f[r("onLoad")]?.forEach(i=>i(o)),f=null},e.onUnload=function(){this[r("onUnload")]?.forEach(s=>s())},e.onShow=function(){this[r("onShow")]?.forEach(s=>s())},e.onHide=function(){this[r("onHide")]?.forEach(s=>s())},console.log(e),Page(e),null}import{defineComponent as se}from"vue";var h;function L(e,t,n){let o=e?.(t,n);if(o!==void 0){let s;return Object.keys(o).forEach(i=>{let a=o[i];if(d(a)){n&&(n[i]=a);return}s=s||{},s[i]=p(a),n&&g.call(h,i,a)}),s!==void 0&&n&&n.setData&&n.setData(s,m),s}}function ie(e){if(!__MINIVUE__)return se(e);let t=e.setup,n=e.props;return e.data=L(t,{},{}),e=T(e,["setup","props"]),e.onLoad=function(o){h=this,L(t,o,h),h[r("onLoad")]?.forEach(i=>i(o)),h=null},e.onUnload=function(){this[r("onUnload")]?.forEach(s=>s())},e.onShow=function(){this[r("onShow")]?.forEach(s=>s())},e.onHide=function(){this[r("onHide")]?.forEach(s=>s())},Component(e),null}import{onMounted as re,onUnmounted as ae,getCurrentInstance as pe}from"vue";var _=document;var J=[],V=[];function B(){_?.visibilityState==="hidden"?V.forEach(e=>e()):J.forEach(e=>e())}_?.addEventListener("visibilitychange",B);function b(e,t,n){let o=r(t);e[o]===void 0&&(e[o]=[]),e[o].push(n)}function v(e){return t=>{if(__MINIVUE__){let n=j();n?b(n,e,t):__DEV__&&console.warn("Page specific lifecycle injection APIs can only be used during execution of setup() in definePage() or defineComponent().")}else{let n=pe();if(e==="onLoad")re(t);else if(e==="onUnload"){if(n){let o=n.onShow||[],s=n.onHide||[];o.forEach(i=>R(o,i)),s.forEach(i=>R(o,i))}ae(t)}else e==="onShow"?(b(n,e,t),J.push(t),B()):e==="onHide"&&(b(n,e,t),V.push(t))}}}var de=v("onLoad"),ce=v("onUnload"),ue=v("onShow"),le=v("onHide");export{Pn as EffectScope,gn as ReactiveEffect,ze as computed,cn as customRef,ie as defineComponent,oe as definePage,yn as effect,vn as effectScope,Rn as getCurrentScope,En as getCurrentWatcher,rn as isProxy,an as isReactive,pn as isReadonly,nn as isRef,dn as isShallow,On as markRaw,le as onHide,de as onLoad,Cn as onScopeDispose,ue as onShow,ce as onUnload,xn as onWatcherCleanup,en as proxyRefs,$e as reactive,Ze as readonly,Ge as ref,mn as shallowReactive,fn as shallowReadonly,ln as shallowRef,Tn as stop,hn as toRaw,tn as toRef,sn as toRefs,on as toValue,un as triggerRef,Xe as unref};
/* istanbul ignore next -- @preserve */
/* istanbul ignore else -- @preserve  */
/* istanbul ignore if -- @preserve  */
/* istanbul ignore if -- @preserve */
