<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <style>
    :root {
      --progress: 75;
      /* 进度百分比 */
    }

    .progress-circle {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 5px solid transparent;
      /* 透明边框 */
      border-image: conic-gradient(#1f69e0 calc(var(--progress) * 3.6deg), #ddd 0deg) 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .popover {
      max-width: 200px;
      background-color: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>

<body>
  <button class="trigger" style="margin: 200px;">test</button>
  <div class="popover">抱歉，我无法直接生成图片。您可以尝试使用 Python 的图像处理库（如 Pillow 或
    Matplotlib）来生成图片。如果需要，我可以为您提供相关代码示例。请告诉我您的具体需求！</div>
  <script>
    function getPopoverPosition(trigger, popover, placement = 'bottom') {
      const t = trigger.getBoundingClientRect();
      const p = { width: popover.offsetWidth, height: popover.offsetHeight };
      const v = { width: window.innerWidth, height: window.innerHeight };
      const gap = 8; // 间距

      // 12个位置的计算公式
      const positions = {
        top: [t.left + t.width / 2 - p.width / 2, t.top - p.height - gap],
        topLeft: [t.left, t.top - p.height - gap],
        topRight: [t.right - p.width, t.top - p.height - gap],
        right: [t.right + gap, t.top + t.height / 2 - p.height / 2],
        rightTop: [t.right + gap, t.top],
        rightBottom: [t.right + gap, t.bottom - p.height],
        bottom: [t.left + t.width / 2 - p.width / 2, t.bottom + gap],
        bottomLeft: [t.left, t.bottom + gap],
        bottomRight: [t.right - p.width, t.bottom + gap],
        left: [t.left - p.width - gap, t.top + t.height / 2 - p.height / 2],
        leftTop: [t.left - p.width - gap, t.top],
        leftBottom: [t.left - p.width - gap, t.bottom - p.height]
      };

      // 检查位置是否在视窗内
      const isInViewport = (x, y) => x >= 0 && y >= 0 && x + p.width <= v.width && y + p.height <= v.height;

      // 计算位置得分(越高越好)
      const getScore = (x, y) => {
        const visible = Math.max(0, Math.min(x + p.width, v.width) - Math.max(x, 0)) *
          Math.max(0, Math.min(y + p.height, v.height) - Math.max(y, 0));
        const centerDistance = Math.abs(x + p.width / 2 - v.width / 2) + Math.abs(y + p.height / 2 - v.height / 2);
        return visible * 1000 - centerDistance;
      };

      // 优先使用指定位置
      const [preferredX, preferredY] = positions[placement] || positions.bottom;
      if (isInViewport(preferredX, preferredY)) {
        return { left: preferredX, top: preferredY, placement };
      }

      // 智能选择最优位置
      let bestPos = null;
      let bestScore = -1;

      for (const [pos, [x, y]] of Object.entries(positions)) {
        const score = getScore(x, y);
        if (score > bestScore) {
          bestScore = score;
          bestPos = { left: x, top: y, placement: pos };
        }
      }

      // 边界修正
      if (bestPos) {
        bestPos.left = Math.max(0, Math.min(bestPos.left, v.width - p.width));
        bestPos.top = Math.max(0, Math.min(bestPos.top, v.height - p.height));
      }

      return bestPos || { left: 0, top: 0, placement: 'fallback' };
    }

    // 使用示例
    const triggerEl = document.querySelector('.trigger');
    const popoverEl = document.querySelector('.popover');

    triggerEl.addEventListener('click', () => {
      const pos = getPopoverPosition(triggerEl, popoverEl, 'bottom');

      Object.assign(popoverEl.style, {
        position: 'fixed',
        left: pos.left + 'px',
        top: pos.top + 'px',
        zIndex: 1000,
        display: 'block'
      });

      console.log(`Popover placed at: ${pos.placement}`);
    });
  </script>
</body>

</html>